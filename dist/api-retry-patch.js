(()=>{var p=Object.defineProperty;var l=(h,e)=>p(h,"name",{value:e,configurable:!0});const g=class g extends CustomModule{constructor(){super({name:"API Retry Patch \u{1F504}",description:"Automatically retries failed API requests for transient network errors",authors:[{name:"Bluscream",description:"VRCX Plugin System Maintainer",userId:"usr_08082729-592d-4098-9a21-83c8dd37a844"}],tags:["Network","API","Utility","Patch","Fix"],required_dependencies:[]}),this.originalMethods=new Map,this.retryStats={totalRetries:0,successfulRetries:0,failedRetries:0}}async load(){const e=window.customjs.types.SettingType;this.settings=this.defineSettings({maxRetries:{type:e.NUMBER,description:"Maximum number of retry attempts",default:3},baseDelay:{type:e.TIMESPAN,description:"Base delay between retries",default:1e3},maxDelay:{type:e.TIMESPAN,description:"Maximum delay between retries",default:1e4},useJitter:{type:e.BOOLEAN,description:"Add random jitter to retry delays",default:!0},retryOnSSLErrors:{type:e.BOOLEAN,description:"Retry on SSL connection errors",default:!0},retryOnTimeouts:{type:e.BOOLEAN,description:"Retry on timeout errors",default:!0},retryOn5xx:{type:e.BOOLEAN,description:"Retry on 5xx server errors",default:!0},retryOn429:{type:e.BOOLEAN,description:"Retry on 429 rate limit errors",default:!0}}),this.logger.log("API Retry Patch plugin loaded"),this.loaded=!0}async start(){this.patchApiMethods(),this.enabled=!0,this.started=!0,this.logger.log("API Retry Patch plugin started"),this.logger.showSuccess("API retry mechanism enabled")}async stop(){this.logger.log("Stopping API Retry Patch plugin"),this.restoreOriginalMethods(),this.logger.log(`Retry stats - Total: ${this.retryStats.totalRetries}, Successful: ${this.retryStats.successfulRetries}, Failed: ${this.retryStats.failedRetries}`),await super.stop()}isRetryableError(e){const s=this.settings.store,t=e?.message||String(e),r=e?.status||0;return!!(s.retryOnSSLErrors&&(t.includes("SSL connection could not be established")||t.includes("ECONNRESET")||t.includes("ETIMEDOUT")||t.includes("ENOTFOUND")||t.includes("EHOSTUNREACH")||t.includes("ENETUNREACH")||t.includes("certificate"))||s.retryOnTimeouts&&(t.includes("timeout")||t.includes("timed out")||r===408)||s.retryOn5xx&&r>=500&&r<600||s.retryOn429&&r===429)}calculateDelay(e){const s=this.settings.store,t=s.baseDelay||1e3,r=s.maxDelay||1e4,i=s.useJitter!==!1;let n=Math.min(t*Math.pow(2,e),r);if(i){const o=Math.random()*.3*n;n=n+o-.15*n}return Math.floor(n)}async sleep(e){return new Promise(s=>setTimeout(s,e))}wrapWithRetry(e,s){const t=this;return l(async function(...i){const n=t.settings.store.maxRetries||3;let o=null;for(let a=0;a<=n;a++)try{const u=await e.apply(this,i);return a>0&&(t.retryStats.successfulRetries++,t.logger.log(`\u2713 Retry successful for ${s} after ${a} attempt(s)`)),u}catch(u){o=u;const m=t.isRetryableError(u),R=a>=n;if(!m||R)throw a>0&&t.retryStats.failedRetries++,u;t.retryStats.totalRetries++;const y=t.calculateDelay(a),c=u?.message||String(u),f=c.length>100?c.substring(0,100)+"...":c;t.logger.log(`\u27F3 Retry attempt ${a+1}/${n} for ${s} (${f}) - waiting ${y}ms`),await t.sleep(y)}throw o},"wrappedWithRetry")}patchApiMethods(){try{const e=window.request;if(!e){this.logger.error("window.request not found, cannot patch API methods");return}const s=[{obj:e.authRequest,name:"verifyOTP"},{obj:e.authRequest,name:"verifyTOTP"},{obj:e.authRequest,name:"verifyEmailOTP"},{obj:e.authRequest,name:"getConfig"},{obj:e.userRequest,name:"getUser"},{obj:e.userRequest,name:"getCachedUser"},{obj:e.userRequest,name:"getUsers"},{obj:e.userRequest,name:"saveCurrentUser"},{obj:e.userRequest,name:"getCurrentUser"},{obj:e.worldRequest,name:"getWorld"},{obj:e.worldRequest,name:"getCachedWorld"},{obj:e.worldRequest,name:"saveWorld"},{obj:e.instanceRequest,name:"getInstance"},{obj:e.instanceRequest,name:"getCachedInstance"},{obj:e.instanceRequest,name:"selfInvite"},{obj:e.instanceRequest,name:"createInstance"},{obj:e.friendRequest,name:"getFriends"},{obj:e.friendRequest,name:"sendFriendRequest"},{obj:e.friendRequest,name:"deleteFriend"},{obj:e.notificationRequest,name:"sendInvite"},{obj:e.notificationRequest,name:"sendRequestInvite"},{obj:e.notificationRequest,name:"getNotifications"},{obj:e.notificationRequest,name:"getNotificationsV2"},{obj:e.avatarRequest,name:"getAvatar"},{obj:e.avatarRequest,name:"saveAvatar"},{obj:e.groupRequest,name:"getGroup"},{obj:e.groupRequest,name:"getGroupMember"}];let t=0;for(const{obj:r,name:i}of s)if(r&&typeof r[i]=="function"){const n=`${r.constructor.name||"unknown"}.${i}`;this.originalMethods.set(n,r[i]),r[i]=this.wrapWithRetry(r[i],i),t++,this.logger.log(`Patched ${i} with retry logic`)}this.logger.log(`Successfully patched ${t} API methods`)}catch(e){this.logger.error(`Failed to patch API methods: ${e.message}`)}}restoreOriginalMethods(){try{const e=window.request;if(!e)return;for(const[s,t]of this.originalMethods.entries()){const[r,i]=s.split("."),n=[e.authRequest,e.userRequest,e.worldRequest,e.instanceRequest,e.notificationRequest,e.friendRequest,e.avatarRequest,e.groupRequest];for(const o of n)if(o&&typeof o[i]<"u"){o[i]=t,this.logger.log(`Restored ${i}`);break}}this.originalMethods.clear()}catch(e){this.logger.error(`Failed to restore methods: ${e.message}`)}}getRetryStats(){return{...this.retryStats}}resetRetryStats(){this.retryStats={totalRetries:0,successfulRetries:0,failedRetries:0},this.logger.log("Retry statistics reset")}wrapFunctionWithRetry(e,s="custom"){return this.wrapWithRetry(e,s)}};l(g,"ApiRetryPatchPlugin");let d=g;window.customjs.__LAST_PLUGIN_CLASS__=d;})();
